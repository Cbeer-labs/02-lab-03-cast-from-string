# Лабораторная работа 3

## Цель

Данная работа позволит студенту:
* узнать об исключениях в С++
* получить навыки обработки исключений
* получить навыки создания новых классов исключений
* получить понимание зачем и когда необходимо использовать механих исключений

## Теория

Исключение — это событие при выполнении функции, которое приводит к её ненормальному или неправильному поведению.

Главная идея обработки исключительных ситуаций состоит в том, что функция, обнаружившая проблему, но не знающая как её решить, генерирует исключение в надежде, что вызвавшая её функция сможет решить возникшую ситуацию.

В С++ для работы с исключениями используются три ключевых слова: `try`, `catch`, `throw`

### Пример работы с исключениями
Для наглядности рассмотрим пример функции "деления", а качестве исключительной ситуации рассмотрим деление на ноль.

```cpp
float div(float a, float b) {
  if (b == 0) {
    throw std::runtime_error("div by zero");
    std::cout << "error";
  }

  return a / b;
}
```
Реализуем фукнцию "деления". Если делитель равен нулю, функция генерирует (на сленге "бросает") исключение.

Чтобы "бросить" исключение применяется ключевое слово `throw`. Далее идет тип ошибки. В примере использован стандартный тип `std::runtime_error`.

**Важно отметить**, что в случае генерации исключения, выполнение кода переходит к ближайшему блоку `try-catch`.
В примере выше, это означает, что если `b == 0`, то функция завершит свою работу на строке `throw`, а строка `std::cout << "error";` никогда не выполнится!

Таким образом, у получилась функция, которая делит одно число на другое, но в случае деления на ноль, функция не может сама определиться с ответом, поэтому она генерирует исключение, чтобы вызывающий код определил, что необходимо выполнить в этом случае.

Теперь рассмотрим, как вызывающий код работает с данной функцией:
```cpp
int main() {
  float a = 0, b = 0;
  std::cin >> a >> b;

  try {
    float c = div(a, b);
    std::cout << c;
  } catch(const std::runtime_error& e) {
    std::cout << e.what();
  }
}
```
Зная, что функция может генерировать исключения, мы помещаем её в блок `try`, который "попробует" выполнить помещенный там код.

В примере выше, там вызывается функция `div`. Если `b != 0`, то все пойдет "хорошо", в переменной `c` будет результат деления, и в основной поток вывода попадет этот ответ. Если же `b == 0`, то будет сгенерировано исключение, выполнение кода перейдет в блок `catch`, а строка `std::cout << c;` не будет выполнена.

### Необработанные исключения
В случае, если программа сгенерировала исключение, которое не попало ни в один блок `catch` и исключение "выходит" за пределы функции `main`, то такая программа будет аварийно завершена.

В C++ есть механизм вызова пользовательской функции в случае необработанных исключений: `std::set_terminate`, `std::set_unexpected`. Но этот механизм используется крайне редко.

### Поиск подходящего блока catch
Блоков `catch` может быть несколько.
```cpp
try {
  foo(a, b);
} catch(const std::runtime_error& e) {
  // обработка исключения типа runtime_error
} catch(const std::logic_error& e) {
  // обработка исключения типа logic_error
} catch(const std::exception& e) {
  // обработка исключения типа exception
} catch(...) {
  // обработка всех оставшихся исключений
}
```
В зависимости от типа исключения сгенерированного в функции `foo`, будет вызван один из блоков `catch`. Поиск соответсвующего типа осуществляется сверху вниз. Поэтому необходимо начинать с узких ошибок и переходя к более широким (об этом ниже).

Как только был найден соответсвующий тип исключения, выполнение программы передается этому блоку. Нижестоящие блоки не будут вызваны.

Если вы хотите обработать все исключительные ситуации, то можно применить `catch(...)`. В этот блок попадут все исключения, которые не были обработаны вышестоящими блоками `catch`. Однако, **НЕ рекомендуется** обрадатывать ошибки подобным образом.

### Вложенные блоки catch
Блоки `try-catch` могут быть вложенными.
```cpp
// Функция может генерировать исключение типа runtime_error
float div(float a, float b);
// Функция может генерировать исключение типа logic_error
float sqrt(float a);

void foo(float a, float b) {
  try {
    std::cout << sqrt(div(a, b));
  } catch(const std::logic_error& e) {
    std::cout << "can't sqrt of negative number";
  }
}

int main() {

  float a = 0, b = 0;
  std::cin >> a >> b;

  try {
    foo(a, b);
    std::cout << "OK";
  } catch(const std::runtime_error& e) {
    std::cout << e.what();
  }
}
```
В примере получаются вложенные блоки `try-catch`: есть внешний блок в функции `main`, а в фукнции `foo` внутренний блок.

Если `b != 0`, то результат деления отрицательное число, то будет сгенерированно исключение типа `logic_error` в функции `sqrt` и это исключение перехватывается внутренним блоком `catch (const std::logic_error&)`. Для внешнего блока `try-catch` все будет "хорошо" и выполнится строка `std::cout << "OK";`, а поиск соответсвующего блока `catch` прекратится в фукнции `foo`.

Если `b == 0`, то будет сгенерированно исключение типа `runtime_error` в функции `div` и это исклчение НЕ перехватывается внутренним блоком `catch`. Т.к. исключение не обработано, то продолжается поиск подходящего блока `catch` среди "внешних" блоков. И такой блок находим в функции `main`. Поэтому будет выполнена строка кода `std::cout << e.what();`, а строка `std::cout << "OK";` не будет выполена.


### Повторная генерация исключений
Бывают случаи, когда неоходимо повторить генерацию того же самого исключения, которое было сгенерировано "выше по стеку".

Например, вызывающий код не может решить возникшую проблему, но хотел бы залоггировать сообщение об ошибке. Такой код может выглядеть примерно следующим образом:

```cpp
void foo() {
  try {
    // ...
    // Тут код, который может генерировать исключения.
  } catch (const std::exception& e) {
    std::cout << "some error: " << e.what(); // логгирование ошибки
    throw; // повторная генерация того же самого исключения
  }
}
```
Такая функция в блоке `try-catch` перехватывает исключения типа `exception` и логгирует сообщения об ошибке. Затем, это самое исключение передается дальше, внешним блокам `try-catch`, которые могут попробовать исправить исключительную ситуацию либо знают что с ней делать.

Таким образом, с помощью `throw;` в блоке `catch` можно передавать возникшие исключения дальше по стеку, т.е. **внешним** блокам `try-catch`. **Нижестоящим** блокам `catch` **нельзя** передать исключение таким образом.


### Обработка наследуемых исключений
В С++ существует механизм наследования классов. О нем будет отдельное занятие. На текущий момент необходимо понимать одно важное свойство наследования:
Публичное (открытое) наследование реализует отношение "является". Т.е если дочерний класс публично наследуется от базового, то он "является" типов базового класса. Например, если класс "грузовик" наследуется от класса "автомобиль", то тут применимо отношение "является": "грузовик" является "автомобилем".

Синктаксис наследования такой:
```cpp
class Car;

class Lorry : public Car {
  // ...
};
```

В связи с этим при обрабтке исключений блок `catch` с базовым классом может обрабатывать исключения дочернего типа.

```cpp
struct Exception {};
struct LogicError : public Exception {};
```
`LogicError` публично наследован от `Exception`, т.е. получается, что `LogicError` является `Exception`.
Поэтому `catch` который обрабатывает исключения типа `Exception` сможет обрабатывать исключения типа `LogicError`.

```cpp
float Sqrt(float a) {
  if (a < 0) {
    throw LogicError{};
  }
  return sqrt(a);
}

int main() {
  float a = 0;
  std::cin >> a;

  try {
    std::cout << Sqrt(a);
  } catch (const Exception&) {
    std::cout << "catch Exception";
  }
}
```
Функция `Sqrt` генерирует исключение `LogicError`. А функция `main` обрабатывает исключения типа `Exception`. Т.к. `LogicErrro` является **публичным** наследником от `Exception`, то `main` обработает исключение сгенерированное функцией `Sqrt`.

Это свойство необходимо помнить. Поэтому при обработке ошибок стоит начинать с более узких классов ошибок (с дочерних классов), а ниже писать более широкие типы ошибок (типы базовых классов). Если запись будет в обратную сторону, то до обработки узких классов ошибок не дойдет.

В стандартной библиотеке все исключения наследованы от базового класса `std::exception`. Иерархию классов стандартной библиотеки можно посмотреть [по ссылке](https://ru.cppreference.com/w/cpp/error/exception).

## Задание

Определите класс исключения `CastException`, унаследовав его от одного из стандартных исключений. Выведите из него несколько классов-наследников.

Создайте шаблонную функцию
```cpp
template <typename T>
inline T FromString(const std::string& );
```
которая преобразовывала бы строку к типам `int`, `bool` и генерировала бы определенные выше исключения разных типов в случае, когда преобразование невозможно (неверный символ, арифметическое переполнение и т.д.).

1. Реализуйте модульные тесты.
1. Продемонстрируйте работу этой шаблонной функции и перехват исключений в модульных тестах.
1. Проверьте в тестах краевые случаи (преобразование из минимального значения типа `int`, максимального, преобразование в тип `bool` используя прописные и строчные буквы и пр.)
1. Покрытие кода тестами должно составлять не менее 85%.

##### Замечание
Нельзя использовать преобразования типов из стандартной библиотеки С++

### Требования к преобразованию bool
Функция преобразования строки в `bool` должна преобразовывать только строки `True`/`true` и `False`/`false` к соответствующему типу.

При попытке преобразовать другие строки, необходимо генерировать исключение с типом "не верные входные данные".

### Требования к преобразованию int
Функция преобразования строки в `int` должна корректно работать со любыми числами в пределах `INT_MAX` и `INT_MIN`.

Числа вида `"-01234"` валидное для преобразования в `int`, как и число `"+4131"` - аналогично валидное число.

Необходимо генерировать следующие исключения:
* арифметическое переполнение - когда число не в ходит в заданый диапазон
* неверный символ - когда в строке встречается нечисловой символ
* пустая строка - в случае если передана пустая строка


### Рекомендации
1. Не забудьте проверить краевые и особые случаи в модульных тестах.
2. [Воспользуйтесь](https://github.com/google/googletest/blob/master/googletest/docs/advanced.md) `EXPECT_THROW`, `EXPECT_ANY_THROW`, `EXPECT_NO_THROW` в тестах для проверки генерируемых исключений.
